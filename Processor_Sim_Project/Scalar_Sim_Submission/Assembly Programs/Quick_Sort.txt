// Sorting the array :
// [570, 151, 394, 597, 756, 424, 610, 5, 883, 299, 
//  162, 320, 366, 917, 481, 842, 545, 722, 438, 109,
//  618, 631, 506, 958, 318, 238, 900, 341, 34, 261]
//
// Initialise counter
ADD r2, r0, r0
// Place array in memory
ADDI r1, r0, 570
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 151
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 394
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 597
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 756
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 424
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 610
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 5
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 883
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 299
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 162
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 320
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 366
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 917
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 481
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 842
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 545
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 722
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 438
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 109
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 618
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 631
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 506
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 958
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 318
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 238
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 900
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 341
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 34
STR r1, r2, 0
ADDI r2, r2, 1
ADDI r1, r0, 261
STR r1, r2, 0
ADDI r2, r2, 1
//
//
//
//Begin quick sort NEXT LINE BELOW IS PC = 91
// r1 = array start location, r2 = array end location
// r3 = low index, r4 = high index, r5 = partition index
// r30 = return pointer, r31 = stack pointer
ADDI r1, r0, 0
ADDI r2, r0, 29
ADD r3, r0, r1
ADD r4, r0, r2
ADDI r31, r0, 40
//Make first (last to access) stack entry HALT PC address
ADDI r30, r0, 137
STR r30, r31, 0
ADDI r31, r31, 1
//
//Quicksort:     PC = 99
BLT r3, r4, 103
SUBI r31, r31, 1
LD r30, r31, 0
JMP r30
//
//
//
//Partition:    PC = 103
//r6 = Pivot, r7 = i, r8 = j, r9 = high - 1
LD r6, r4, 0
SUBI r7, r3, 1
//for (j = low; j <= high- 1; j++)
//    {
//        // If current element is smaller than the pivot
//        if (arr[j] < pivot)
//        {
//            i++;    // increment index of smaller element
//            swap arr[i] and arr[j]
//        }
//    }
ADD r8, r0, r3
SUBI r9, r4, 1
//r10 = array[j]     PC below = 107
LD r10, r8, 0
BLT r10, r6, 110
BR 114
ADDI r7, r7, 1
LD r11, r7, 0
STR r11, r8, 0
STR r10, r7, 0
//end of loop       PC below = 114
ADDI r8, r8, 1
BLT r8, r9, 107
BEQ r8, r9, 107
//last of partition function
LD r11, r7, 1
LD r12, r4, 0
STR r11, r4, 0
STR r12, r7, 1
//Set partition index to i + 1        PC below =  121
ADDI r5, r7, 1
//
//
//save low, high, partition index to stack          PC below = 122
STR r3, r31, 0
STR r4, r31, 1
STR r5, r31, 2
ADDI r31, r31, 3
//
//save return address
ADDI r30, r0, 131
STR r30, r31, 0
ADDI r31, r31, 1
//
//
//set high to PI - 1
SUBI r4, r5, 1
//Branch to Quicksort
BR 99
//
//PC below = 131
//
LD r5, r31, -1
LD r4, r31, -2
LD r3, r31, -3
SUBI r31, r31, 3
//
//set low to PI + 1
ADDI r3, r5, 1
//Branch to Quicksort
BR 99
//PC below = 137
HALT